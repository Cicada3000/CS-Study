# 8월 20일 CS
## 절차지향 프로그래밍과 객체지향 프로그래밍

- 절차지향 프로그래밍 : 순차적인 처리를 중요시 하며, 프로그램 전체가 유기적으로 연결되도록 하는 프로그램
   - 각 단계를 함수나 프로시저(Procedure)로 구분하여 실행하는 방식이다.
   - 여기서 프로시저에는 루틴, 서브루틴, 함수 등이 포함된다.
      - 서브루틴이란 main 문 밖에서 정의한 코드 블럭 중 return 값이 없는 것을 의미한다.
   - 장점 : 컴퓨터의 처리방식이랑 유사하여 실행 속도가 비교적 빠르다.
   - 단점 : 처리 과정이 유기적으로 연결되어 있어 유지보수에 어려움이 있다. 
- 객체지향 프로그래밍 : 프로그램을 명령어의 목록으로 보는 것이 아닌, 여러 개의 객체로 구성되어 있다고 파악하는 것
   - 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
   - 객체(Object) : 데이터와 기능을 묶어서 생각하는 형태
   - 장점 : 코드의 재사용성이 높아지며, 유지보수에 용이하다. 가독성이 높으며, 대형프로젝트에 적합하다.
   - 단점 : 절차지향 프로그래밍보다 속도가 느리다. 객체가 많아지면 용량이 커진다.

## MVC, MVP, MVVM
- 디자인 패턴 : 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책을 의미한다.
### MVC
- **Model + View + Controller**
   - Model : 어플리케이션에서 사용되는 데이터와 데이터를 처리하는 비즈니스 로직을 담당한다.
   - View : UI (사용자 인터페이스)를 담당한다. 모델의 데이터를 표시해준다.
   - Controller : 사용자의 **입력을 받고** 처리한다. 즉 모델과 뷰 간의 통신을 처리한다.
- 실행 : 사용자의 입력이 **컨트롤러**에서 처리되며, 이를 통해 모델을 업데이트한다. 이후 컨트롤러가 뷰를 선택하게 된다.
   - 컨트롤러가 뷰를 선택하므로, 1 : n 의 관계가 성립한다고 할 수 있다.
   - 주의 : 컨트롤러가 뷰를 직접 업데이트 하는 것이 아니다!
- 웹 어플리케이션 개발 등에 사용된다.
- Model과 View 사이에 의존성이 있다.
### MVP
- **Model + View + Presenter**
   - MVC에서 **Model과 View 간의 의존성을 없앤 패턴**이다.
   - Model : 어플리케이션에서 사용되는 데이터와 데이터를 처리하는 비즈니스 로직을 담당한다.
   - View : UI (사용자 인터페이스)를 담당한다. 프레젠터의 지시를 받아 화면에 정보를 표시한다. **또한 입력을 전달받는다.**
   - Presenter : 사용자 입력을 처리하고 뷰와 모델을 연결한다.
      - 프레젠터가 입력에 대응하는 모델을 업데이트하고, 이 업데이트를 기반으로 View를 업데이트한다.
      - 프레젠터가 중계기 역할을 하면서, 둘 사이의 직접적인 의존성을 없애준다.
      - **단, 프로그램이 복잡해질수록 뷰와 프레젠터의 의존성이 강해진다. 뷰와 모델이 1대 1 관계이기 때문**
   - 안드로이드 어플리케이션 개발에서 주로 사용되는 형태이다.
### MVVM
- **Model + View + View Model**
   - MVC 및 MVP에서 발생하는 Model과 View 간의 의존성과 Controller(Presenter)와 View 간의 의존성을 고려하였다.
   - 즉 각 요소가 독립적으로 작동할 수 있게끔 설계된 모델이다. 이 때문에 설계 상 어려움이 상당하다.
   - Model : 어플리케이션에서 사용되는 데이터와 데이터를 처리하는 비즈니스 로직을 담당한다.
   - View : UI (사용자 인터페이스)를 담당한다. 단 이 모델에서는 **뷰의 로직이 최소화되고 이를 뷰 모델에 위임한다.**
   - View Model : **뷰를 위한 논리와 데이터를 제공한다.** 뷰를 나타내기 위한 모델이자 뷰를 나타내기 위한 데이터 처리를 담당한다.
      - 즉, 뷰와 모델 사이에서 데이터 변환 및 처리를 담당한다.
      - 뷰 모델에서 로직을 통해 데이터를 처리하고 뷰로 전달하므로, 독립적인 관계가 유지된다. 또한 이 관계는 **1 : n** 이다.
      - 모델 변경 시 해당 뷰 모델을 이용하는 뷰가 자동으로 업데이트된다. 