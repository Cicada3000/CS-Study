# 자료구조

- Stack
- Queue
- LinkedList
- ArrayList
- Array
- Map
- Set
- HashMap
- HashSet
- heap

시간복잡도, 공간복잡도, 특징,  
사용하면 좋은(유리한) 상황

## 시간복잡도

문제를 해결하는데 걸리는 시간과 입력의 함수 관계

## 공간복잡도

프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

총 필요 저장 공간  
고정 공간 (알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수  
가변 공간 (알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간

ex) 제자리 정렬이 되는 알고리즘(삽입정렬)의 경우 O(N)

## Stack

후입선출(Last In First Out)

먼저 들어간 것이 밑에 위치하게 된다.

프링글스 통을 생각하면 될듯

컴퓨터가 연산을 할때 사용하는 자료구조이다.

- 중위 표기법(infix notation): 연산자를 피연산자의 사이에 표기하는 방법; A+B
- 전위 표기법(prefix notation): 연산자를 피연산자의 앞에 표기하는 방법; +AB
- 후위 표기법(postfix notation): 연산자를 피연산자의 뒤에 표기하는 방법; AB+

### 후위표기법

- 후위표기법의 장점

1. 괄호를 사용하지 않고도 계산해야할 순서를 알 수 있다.

2. 연산자의 우선순위를 생각할 필요가 없다. 식 자체에 우선순위가 이미 포함되어 있기 때문이다.

3. 수식을 읽으면서 바로 계산할 수 있다. (중위 표현식은 괄호와 연산자의 우선순위 때문에 수식을 끝까지 읽은 다음에야 계산이 가능하다.)

- 후위수식 계산

1. 왼쪽에서 오른쪽 방향으로 스캔
2. 피연산자는 스택에 저장, 연산자가 나오면 스택에서 피연산자 2개 꺼내 연산실행 후 다시 스택에 저장
3. 2번을 계속반복하면 마지막에 최종 결과만이 스택에 남는다.

### 시간복잡도

| 삽입 | 삭제(pop) | 삭제(remove) | 검색 |
| :--: | :-------: | :----------: | :--: |
| O(1) |   O(1)    |     O(N)     | O(N) |

※스택의 삽입과 삭제 연산은 항상 top에서만 일어나므로

삽입과 삭제에 소요되는 시간복잡도는 O(1)로 고정

## Queue

선입선출(First In First Out)

| 삽입 | 삭제(deque) | 삭제(remove) | 검색 |
| :--: | :---------: | :----------: | :--: |
| O(1) |    O(1)     |     O(N)     | O(N) |

파이프나 줄 서기 느낌

먼저 들어온 걸 먼저 사용하기 때문에  
운영체제에서 Ready 큐 또는 대기큐 등등을 사용한다.

## LinkedList

Node 들이 서로 연결되어있다.  
맨 앞은 head, 맨 뒤는 tail

| 삽입 | 삭제 | 탐색 | 검색 |
| :--: | :--: | :--: | :--: |
| O(1) | O(1) | O(N) | O(N) |

삽입과 삭제할때엔 앞뒤 연결고리를 끊고 바로 이어주기 때문에 O(1)이다.  
그러나 삽입/삭제 연산 자체는 O(1)이지만 그 지점까지 접근하는데 걸리는 시간이 있기 때문에 현실적으로는 O(N)이다.

여러 자료구조들을 구현 가능하다.

## ArrayList & Array

Array는 고정된 길이의 자료구조이지만,  
ArrayList은 가변길이의 자료구조이다. (C++의 Vector과 비슷)

| 삽입 | 삭제 | 수정 | 검색 | 접근 |
| :--: | :--: | :--: | :--: | :--: |
| O(N) | O(N) | O(1) | O(N) | O(1) |

Array는 고정된 공간을 가지기에 O(1) 공간복잡도를 가진다.  
-> in-place 정렬이 아닌 알고리즘인 경우엔 O(N)

## ArrayList과 LinkedList

ArrayList는 탐색이 상수시간이기 때문에 탐색이 삽입이나 삭제보다 많은 경우에 사용하는것이 좋다.

LinkedList은 삽입/삭제 연산에서 상수시간이 걸린다.

ArrayList-> 데이터 접근이 빠름, LinkedList-> 데이터 삽입/삭제가 빠름

LinkedList는 데이터의 저장이 볼연속적이기 때문에 ArrayList에 비해 지역성이 떨어진다.  
그러나 크기를 resize 할 필요가 없다는 장점이 있다.

## Map

{Key,Value} Key와Value가 쌍으로 이루어진 자료구조이다.  
파이썬의 딕셔너리와 같은 구조이지만 c++의 map은 오름차순으로 자동 정렬을 한다.

Key는 중복이 되지 말아야 한다.

- HashMap  
  key와 value의 쌍으로만 구성이 될뿐 자료구조 안에 묶인 쌍들에 대한 순서는 보장할 수 없다.  
  즉, 사용자는 키와 값이 구성되는 위치를 결정 하거나 알 수 없다.
  Null 값을 허용한다.

- HashTable
  Null 값을 허용하지 않는다.
  평균적으로 탐색/삽입/삭제가 O(1) 이지만 충돌이 일어날 수 있기 때문에  
  최악의 경우 전부 O(N)이다.

- TreeMap->stl::map  
  이진검색트리 구조의 맵  
   key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조  
   저장시 Key기준으로 저장이 된다.
  key값을 통한 탐색 뿐 아니라 key값의 정렬을 통한 탐색 등을 하기에 용의 하다.
- LinkedHashMap  
  데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조  
  배열, 리스트처럼 인덱싱 접근을 하기에 용의 하다.

|   삽입    |   삭제    |   탐색    | 접근 |
| :-------: | :-------: | :-------: | :--: |
| O(log(n)) | O(log(n)) | O(log(n)) | O(1) |

## Set

집합, 순서가 없다, 중복된 데이터가 들어갈 수 없다.

중복되지않는 데이터들을 구할 때 사용하면 유용하다.

HashSet의 경우 정렬을 해주지 않고  
TreeSet은 자동정렬을 해준다.

|   삽입    |   삭제    |   탐색    |
| :-------: | :-------: | :-------: |
| O(log(n)) | O(log(n)) | O(log(n)) |

c++ stl에서의 set과 map은 둘다 [레드블랙트리](https://zeddios.tistory.com/237) 로 이루어져 있어 시간복잡도를 보장한다. -> 자동정렬도 된다.  
unordered_map은 자동정렬이 되지 않음

## heap

완전 이진트리의 일종이다.  
우선순위 큐를 구성할때 쓰임

중복된 값을 허용하고 약간 정렬된 상태를 유지한다.

- 최대 힙  
  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같다.

- 최소 힙  
  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같다.

보통 배열로 가능하다.  
1 start이다. -> 0start하면 구현이 어려움

삽입연산 -> 맨 끝 자리에 원소 삽입 O(1)  
-> 맨 끝원소를 다시 힙 화 시킨다 O(log(N))

삭제연산 -> 루트 노드를 삭제한다. O(1)  
-> 맨 끝원소를 루트 노드 자리에 넣고 다시 힙 화 시킨다 O(log(N))

|   삽입    |   삭제    |
| :-------: | :-------: |
| O(log(n)) | O(log(n)) |
