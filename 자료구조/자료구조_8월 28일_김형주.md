# 8월 28일 CS

stack queue linked list array list
array map set hashmap hashset heap

## Stack과 Queue
- Stack : 데이터를 단어 그대로 **쌓아 올리는 형태**의 자료구조
   - 한쪽 끝에서만(TOP) 자료를 밀어넣는 PUSH, 자료를 꺼내는 POP이 이루어진다.
   - LAST IN, FIRST OUT 구조를 띄는 선형 자료구조이다.
   - 삽입 : O(1) / 삭제 : O(1) / 탐색 : O(n)
- Queue : 먼저 넣은 데이터가 먼저 나오는, 입구와 출구가 존재하는 자료구조 형태이다. 스택의 반대 개념이라고도 할 수 있다.
   - enqueue(삽입) : O(1) / dequeue : O(1) / 탐색 : O(n)
   - enqueue는 큐의 **뒤(rear)** 에서 이루어지고, dequeue는 큐의 **앞(front)** 에서 이루어진다.
   - 대표적인 사용 예시 : **너비 우선 탐색 BFS**, 프린트 작업 등

## BFS 예시 살펴보기

- **큐**를 사용한다.
- 빠른 알파벳이 먼저 선택된다고 가정하자 (간선 포함).
- 맨 처음 visit하는 A를 큐에 삽입하고, visit으로 바꾼다.
- 들어가자마자 dequeue하며, 이 때 A.instantEdges()를 계산한다.
  - 처음에 B의 간선을 따라 B를 탐색하며, B가 unexplored 상태이므로 visit 상태로 바꾸고 큐에 넣는다. 해당 작업을 정점 C, F에 대해서도 반복한다.
  - 따라서 B, C, D의 **d = 1**이다. 여기서 d는 **출발점으로부터의 간선 수 (최단거리)** 이다.
- B를 dequeue하며, B기준 **d = 2**에 해당하는 값인 D를 visit 상태로 바꾸고 큐에 넣는다.
- C, F도 마찬가지로 dequeue 하나 enqueue 하는 값은 없다.
- 1차 BFS는 E, G를 탐색하지 못하고 종료된다. E, G는 2차 탐색에서 진행된다.
- 한 정점에서 진행하는 일은 **O(1) + deg(v)** 로 동일하다. 따라서 총량도 **O(n + m)** 으로 동일하다.

## List
- 배열은 인덱스를 가지고 있지만, 리스트는 배열과 달리 인덱스를 포기하고 자료의 빈틈없는 적재를 목표로 하는 **추상 자료형**이다.

### Array List
- **연속된 메모리 공간**에 자료들을 저장한다.
- 데이터가 빈틈없이 적재되기 때문에, 삽입 또는 삭제가 중간에서 이루어지면 다른 자료들의 인덱스를 재조정하는 과정이 필요하다. 
   - 따라서, 삽입 및 삭제에 걸리는 시간은 **O(n)** 이다.
   - 탐색에 걸리는 시간도 마찬가지로 **O(n)** 이다. 인덱스 활용 시 O(1)
- **처음에 배열의 크기는 고정이다.** 만약 이를 넘어서는 데이터를 저장하고 싶다면, 새로운 배열을 할당하고 데이터를 옮겨줘야 한다.

### Linked List
- 일반적으로 데이터가 메모리 상에 연속적으로 있지는 않다.
   - 각자 **다음 지목 대상**이 있다고 생각하면 된다. 이 역할을 **포인터**가 한다.
   - 따라서 처음에 그 크기가 고정되지 않는다. **가변적이다.**
- Array list와 달리 인덱스 확인이 불가능하므로, 선형 탐색해야 한다. 따라서 탐색 간 **O(n)** 이 소요된다.
   - 이에 따라 삽입 삭제도 **O(n)** 이 소요된다.

## DFS : 인접 리스트 구현 <분석>

- **각 정점마다의 DFS(v) 수행시간**은,
  - 한 edge를 visit(v)하는데 걸리는 시간은 **O(1)** 이다.
  - v에서 v.incidentEdges()를 수행하는데 걸리는 시간은 **deg(v)** 이다.
    - 모든 간선을 확인 후 상태를 바꾸는 데 걸리는 시간이 각각 O(1)이기 때문이다.
- 따라서 결과는 **O(1) + deg(v)** 이며, 총 수행시간은 모든 노드에 대하여,
- **O(n + m)** 이다.

## Map, Set
- Map : 자료를 **유일한 key와 하나의 value의 쌍**으로 저장하는 자료구조
   - key와 value의 자료형은 당연히 다를 수 있다.
   - 보통 key 값을 기준으로 (내부에서) 오름차순 정렬한다.
      - 정렬이 가능하다. **key값이 유일하기 때문**
- Hash Map : Map 인터페이스를 구현한 것이며, map과 같이 key와 value 쌍을 저장한다.
   - 각 키가 **고유한 해시 값으로 대응**한다. 이를 인덱스로 활용하여 배열에 값을 저장하게 된다.
   - 따라서 키를 통한 **빠른 탐색**이 가능하다. 삽입 및 탐색이 상수 시간 **O(1)** 에 이루어진다.
- Set : 수학의 집합 개념과 유사한 **중복을 허용하지 않는** 값의 모음을 지칭하는 추상 자료형이다.
   - 개체들의 순서를 보장하지는 않는다. Ordered set으로 순서를 보장해줄 수 있긴 하다.
- Hash Set : Set 인터페이스를 구현한 것이다.
   - **null 요소도 허용한다.**
   - **Non-ordered set** 기반이다. 즉 자료 정렬 간 순서가 가변적이다.
   - 중복을 허용하지 않는다. 즉 중복되지 않은 값이 모여 구성된다.
   - 삽입 : O(1) / 삭제 : O(1) / 탐색 : O(1), 단 충돌이 발생할 경우 linear time 까지 늘어날 수 있다.

## Heap
- Heap : 완전 이진 트리의 일종으로, **priority queue**를 위해 만들어진 자료구조이다.
   - 즉, 특정 범위의 값 중에서 최댓값이나 최솟값을 빠르게 찾아내기 위한 목적이 있다.
- 배열로 구현이 가능하다.
   - 이 때, 구현 간 0번째 인덱스는 보통 사용하지 않는다.
   - 삽입 : O(log n) / 삭제 : O(log n)
- **입력을 배열로 줬을 때,**
    - downheap 과정 간 모든 parent node가 leaf node 까지 도달할 때가 worst case 이므로,
    - 이 때의 지나간 경로의 수는 **n - h** (h는 height) 이다.
    - 한 번 내려갈 때의 비교 연산을 2번 시행하므로, 총 비교 연산 수는 **2\*(n - h)**
    - 따라서 Heap construction은 **O(n) : linear time** 에 시행된다.
    - 힙 정렬 간 시간은 **accelerated Heapsort**로도 단축이 가능하다.

### (Binary) Heap이란?

- 구조 조건 : **complete-binary tree** (완전이진트리)
- 순서 조건 : **partial order** (일부 데이터에 대해서 property 만족)

※ 포화 이진트리 : 임의의 height h에 대하여, 전부 차있는 트리

※ 완전 이진트리 : 임의의 height h에 대하여, 왼쪽부터 노드가 추가되는 트리

- 즉, h-1 까지는 포화 이진트리이다.